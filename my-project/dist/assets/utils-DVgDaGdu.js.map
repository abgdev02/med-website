{"version":3,"file":"utils-DVgDaGdu.js","sources":["../../src/utils/LRUCache.ts","../../src/utils/AnimationScheduler.ts","../../src/utils/FrustumCuller.ts","../../src/utils/SpatialHashGrid.ts","../../src/utils/PerformanceMonitor.ts"],"sourcesContent":["/**\r\n * LRU (Least Recently Used) Cache implementation\r\n * Optimizes memory usage by automatically evicting least used items\r\n */\r\nexport class LRUCache<K, V> {\r\n  private cache = new Map<K, V>()\r\n  private maxSize: number\r\n\r\n  constructor(maxSize: number) {\r\n    this.maxSize = maxSize\r\n  }\r\n\r\n  get(key: K): V | undefined {\r\n    const value = this.cache.get(key)\r\n    if (value !== undefined) {\r\n      // Move to end (most recently used)\r\n      this.cache.delete(key)\r\n      this.cache.set(key, value)\r\n    }\r\n    return value\r\n  }\r\n\r\n  set(key: K, value: V): void {\r\n    if (this.cache.has(key)) {\r\n      this.cache.delete(key)    } else if (this.cache.size >= this.maxSize) {\r\n      // Remove least recently used (first item)\r\n      const firstKey = this.cache.keys().next().value\r\n      if (firstKey !== undefined) {\r\n        this.cache.delete(firstKey)\r\n      }\r\n    }\r\n    this.cache.set(key, value)\r\n  }\r\n\r\n  has(key: K): boolean {\r\n    return this.cache.has(key)\r\n  }\r\n\r\n  delete(key: K): boolean {\r\n    return this.cache.delete(key)\r\n  }\r\n\r\n  clear(): void {\r\n    this.cache.clear()\r\n  }\r\n\r\n  size(): number {\r\n    return this.cache.size\r\n  }\r\n\r\n  keys(): IterableIterator<K> {\r\n    return this.cache.keys()\r\n  }\r\n\r\n  values(): IterableIterator<V> {\r\n    return this.cache.values()\r\n  }\r\n}\r\n","/**\r\n * Animation task interface for priority-based scheduling\r\n */\r\nexport interface AnimationTask {\r\n  id: string\r\n  priority: number\r\n  callback: (deltaTime: number) => void\r\n  lastUpdate: number\r\n  updateInterval: number\r\n  enabled: boolean\r\n}\r\n\r\n/**\r\n * Priority-based animation scheduler\r\n * Optimizes performance by prioritizing important animations and managing frame budget\r\n */\r\nexport class AnimationScheduler {\r\n  private tasks: AnimationTask[] = []\r\n  private frameTime = 16.67 // Target 60fps\r\n  private maxFrameBudget = 0.8 // Use 80% of frame budget\r\n  private isRunning = false\r\n  private lastFrameTime = 0\r\n\r\n  addTask(task: Omit<AnimationTask, 'lastUpdate' | 'enabled'>): void {\r\n    const newTask: AnimationTask = { \r\n      ...task, \r\n      lastUpdate: performance.now(),\r\n      enabled: true \r\n    }\r\n    this.tasks.push(newTask)\r\n    this.sortByPriority()\r\n  }\r\n\r\n  removeTask(id: string): void {\r\n    this.tasks = this.tasks.filter(task => task.id !== id)\r\n  }\r\n\r\n  enableTask(id: string): void {\r\n    const task = this.tasks.find(t => t.id === id)\r\n    if (task) task.enabled = true\r\n  }\r\n\r\n  disableTask(id: string): void {\r\n    const task = this.tasks.find(t => t.id === id)\r\n    if (task) task.enabled = false\r\n  }\r\n\r\n  update(deltaTime: number): void {\r\n    if (!this.isRunning) return\r\n\r\n    const now = performance.now()\r\n    const budget = this.frameTime * this.maxFrameBudget\r\n    const startTime = now\r\n\r\n    // Process tasks in priority order within frame budget\r\n    for (const task of this.tasks) {\r\n      if (now - startTime > budget) break // Prevent frame drops\r\n      if (!task.enabled) continue\r\n      \r\n      if (now - task.lastUpdate >= task.updateInterval) {\r\n        try {\r\n          task.callback(deltaTime)\r\n          task.lastUpdate = now\r\n        } catch (error) {\r\n          console.warn(`Animation task ${task.id} failed:`, error)\r\n        }\r\n      }\r\n    }\r\n\r\n    this.lastFrameTime = now\r\n  }\r\n\r\n  updatePriority(id: string, newPriority: number): void {\r\n    const task = this.tasks.find(t => t.id === id)\r\n    if (task) {\r\n      task.priority = newPriority\r\n      this.sortByPriority()\r\n    }\r\n  }\r\n\r\n  updateInterval(id: string, newInterval: number): void {\r\n    const task = this.tasks.find(t => t.id === id)\r\n    if (task) {\r\n      task.updateInterval = newInterval\r\n    }\r\n  }\r\n\r\n  start(): void {\r\n    this.isRunning = true\r\n  }\r\n\r\n  stop(): void {\r\n    this.isRunning = false\r\n  }\r\n\r\n  clear(): void {\r\n    this.tasks = []\r\n  }\r\n\r\n  getTaskCount(): number {\r\n    return this.tasks.filter(t => t.enabled).length\r\n  }\r\n\r\n  getFrameStats(): { budget: number; usage: number; efficiency: number } {\r\n    const now = performance.now()\r\n    const frameUsage = now - this.lastFrameTime\r\n    const budgetUsed = this.frameTime * this.maxFrameBudget\r\n    return {\r\n      budget: budgetUsed,\r\n      usage: frameUsage,\r\n      efficiency: budgetUsed > 0 ? (budgetUsed - frameUsage) / budgetUsed : 1\r\n    }\r\n  }\r\n\r\n  private sortByPriority(): void {\r\n    this.tasks.sort((a, b) => b.priority - a.priority) // Higher priority first\r\n  }\r\n}\r\n\r\n// Global animation scheduler instance\r\nexport const globalAnimationScheduler = new AnimationScheduler()\r\nglobalAnimationScheduler.start()\r\n","import * as THREE from 'three'\r\n\r\n/**\r\n * Frustum culling system for efficient 3D object visibility management\r\n * Only renders objects that are visible to the camera\r\n */\r\nexport class FrustumCuller {\r\n  private frustum = new THREE.Frustum()\r\n  private cameraMatrix = new THREE.Matrix4()\r\n  private objects = new Map<string, { object: THREE.Object3D; bounds: THREE.Box3 }>()\r\n\r\n  addObject(id: string, object: THREE.Object3D, customBounds?: THREE.Box3): void {\r\n    let bounds: THREE.Box3\r\n    \r\n    if (customBounds) {\r\n      bounds = customBounds.clone()\r\n    } else {\r\n      bounds = new THREE.Box3().setFromObject(object)\r\n    }\r\n    \r\n    this.objects.set(id, { object, bounds })\r\n  }\r\n\r\n  removeObject(id: string): void {\r\n    this.objects.delete(id)\r\n  }\r\n\r\n  updateCamera(camera: THREE.Camera): void {\r\n    this.cameraMatrix.multiplyMatrices(camera.projectionMatrix, camera.matrixWorldInverse)\r\n    this.frustum.setFromProjectionMatrix(this.cameraMatrix)\r\n  }\r\n\r\n  cullObjects(): { \r\n    visible: Array<{ id: string; object: THREE.Object3D }>\r\n    hidden: Array<{ id: string; object: THREE.Object3D }>\r\n  } {\r\n    const visible: Array<{ id: string; object: THREE.Object3D }> = []\r\n    const hidden: Array<{ id: string; object: THREE.Object3D }> = []\r\n\r\n    for (const [id, { object, bounds }] of this.objects.entries()) {\r\n      // Update bounds to world position\r\n      const worldBounds = bounds.clone()\r\n      worldBounds.applyMatrix4(object.matrixWorld)\r\n\r\n      if (this.frustum.intersectsBox(worldBounds)) {\r\n        visible.push({ id, object })\r\n        object.visible = true\r\n      } else {\r\n        hidden.push({ id, object })\r\n        object.visible = false\r\n      }\r\n    }\r\n\r\n    return { visible, hidden }\r\n  }\r\n\r\n  isVisible(id: string): boolean {\r\n    const item = this.objects.get(id)\r\n    if (!item) return false\r\n\r\n    const worldBounds = item.bounds.clone()\r\n    worldBounds.applyMatrix4(item.object.matrixWorld)\r\n    \r\n    return this.frustum.intersectsBox(worldBounds)\r\n  }\r\n\r\n  getVisibleObjects(): Array<{ id: string; object: THREE.Object3D }> {\r\n    const visible: Array<{ id: string; object: THREE.Object3D }> = []\r\n\r\n    for (const [id, { object, bounds }] of this.objects.entries()) {\r\n      const worldBounds = bounds.clone()\r\n      worldBounds.applyMatrix4(object.matrixWorld)\r\n\r\n      if (this.frustum.intersectsBox(worldBounds)) {\r\n        visible.push({ id, object })\r\n      }\r\n    }\r\n\r\n    return visible\r\n  }\r\n\r\n  updateObjectBounds(id: string, newBounds?: THREE.Box3): void {\r\n    const item = this.objects.get(id)\r\n    if (!item) return\r\n\r\n    if (newBounds) {\r\n      item.bounds = newBounds.clone()\r\n    } else {\r\n      item.bounds = new THREE.Box3().setFromObject(item.object)\r\n    }\r\n  }\r\n\r\n  clear(): void {\r\n    this.objects.clear()\r\n  }\r\n\r\n  getStats(): {\r\n    totalObjects: number\r\n    visibleCount: number\r\n    hiddenCount: number\r\n    cullingEfficiency: number\r\n  } {\r\n    const totalObjects = this.objects.size\r\n    const { visible, hidden } = this.cullObjects()\r\n    const visibleCount = visible.length\r\n    const hiddenCount = hidden.length\r\n    const cullingEfficiency = totalObjects > 0 ? hiddenCount / totalObjects : 0\r\n\r\n    return {\r\n      totalObjects,\r\n      visibleCount,\r\n      hiddenCount,\r\n      cullingEfficiency\r\n    }\r\n  }\r\n}\r\n\r\n/**\r\n * Level of Detail (LOD) manager based on distance from camera\r\n */\r\nexport class LODManager {\r\n  private objects = new Map<string, {\r\n    object: THREE.Object3D\r\n    lodLevels: Array<{ distance: number; quality: 'low' | 'medium' | 'high' }>\r\n    currentLOD: 'low' | 'medium' | 'high'\r\n  }>()\r\n  \r\n  private cameraPosition = new THREE.Vector3()\r\n\r\n  addObject(\r\n    id: string, \r\n    object: THREE.Object3D, \r\n    lodLevels: Array<{ distance: number; quality: 'low' | 'medium' | 'high' }>\r\n  ): void {\r\n    // Sort LOD levels by distance (closest first)\r\n    const sortedLevels = lodLevels.sort((a, b) => a.distance - b.distance)\r\n    \r\n    this.objects.set(id, {\r\n      object,\r\n      lodLevels: sortedLevels,\r\n      currentLOD: 'high' // Default to highest quality\r\n    })\r\n  }\r\n\r\n  removeObject(id: string): void {\r\n    this.objects.delete(id)\r\n  }\r\n\r\n  updateCamera(camera: THREE.Camera): void {\r\n    this.cameraPosition.setFromMatrixPosition(camera.matrixWorld)\r\n  }\r\n\r\n  updateLOD(): Array<{ id: string; newLOD: 'low' | 'medium' | 'high'; distance: number }> {\r\n    const updates: Array<{ id: string; newLOD: 'low' | 'medium' | 'high'; distance: number }> = []\r\n\r\n    for (const [id, item] of this.objects.entries()) {\r\n      const objectPosition = new THREE.Vector3()\r\n      objectPosition.setFromMatrixPosition(item.object.matrixWorld)\r\n      \r\n      const distance = this.cameraPosition.distanceTo(objectPosition)\r\n      \r\n      // Find appropriate LOD level\r\n      let newLOD: 'low' | 'medium' | 'high' = 'high'\r\n      \r\n      for (const level of item.lodLevels) {\r\n        if (distance >= level.distance) {\r\n          newLOD = level.quality\r\n        }\r\n      }\r\n\r\n      if (newLOD !== item.currentLOD) {\r\n        item.currentLOD = newLOD\r\n        updates.push({ id, newLOD, distance })\r\n      }\r\n    }\r\n\r\n    return updates\r\n  }\r\n\r\n  getLOD(id: string): 'low' | 'medium' | 'high' | null {\r\n    const item = this.objects.get(id)\r\n    return item ? item.currentLOD : null\r\n  }\r\n\r\n  getDistance(id: string): number | null {\r\n    const item = this.objects.get(id)\r\n    if (!item) return null\r\n\r\n    const objectPosition = new THREE.Vector3()\r\n    objectPosition.setFromMatrixPosition(item.object.matrixWorld)\r\n    \r\n    return this.cameraPosition.distanceTo(objectPosition)\r\n  }\r\n\r\n  clear(): void {\r\n    this.objects.clear()\r\n  }\r\n}\r\n","import * as THREE from 'three'\r\n\r\n/**\r\n * 3D Spatial Hash Grid for efficient proximity queries\r\n * Optimizes distance calculations and collision detection\r\n */\r\nexport class SpatialHashGrid {\r\n  private cellSize: number\r\n  private grid = new Map<string, Set<string>>()\r\n  private objects = new Map<string, THREE.Vector3>()\r\n\r\n  constructor(cellSize: number) {\r\n    this.cellSize = cellSize\r\n  }\r\n\r\n  private hash(x: number, y: number, z: number): string {\r\n    const gridX = Math.floor(x / this.cellSize)\r\n    const gridY = Math.floor(y / this.cellSize)\r\n    const gridZ = Math.floor(z / this.cellSize)\r\n    return `${gridX},${gridY},${gridZ}`\r\n  }\r\n\r\n  insert(id: string, position: THREE.Vector3): void\r\n  insert(id: string, x: number, y: number, z: number): void\r\n  insert(id: string, positionOrX: THREE.Vector3 | number, y?: number, z?: number): void {\r\n    this.remove(id) // Remove from old position\r\n    \r\n    let x: number, yPos: number, zPos: number\r\n    \r\n    if (typeof positionOrX === 'number') {\r\n      x = positionOrX\r\n      yPos = y!\r\n      zPos = z!\r\n    } else {\r\n      x = positionOrX.x\r\n      yPos = positionOrX.y\r\n      zPos = positionOrX.z\r\n    }\r\n    \r\n    const key = this.hash(x, yPos, zPos)\r\n    if (!this.grid.has(key)) {\r\n      this.grid.set(key, new Set())\r\n    }\r\n    this.grid.get(key)!.add(id)\r\n    this.objects.set(id, new THREE.Vector3(x, yPos, zPos))\r\n  }\r\n\r\n  remove(id: string): void {\r\n    const obj = this.objects.get(id)\r\n    if (obj) {\r\n      const key = this.hash(obj.x, obj.y, obj.z)\r\n      const cell = this.grid.get(key)\r\n      if (cell) {\r\n        cell.delete(id)\r\n        if (cell.size === 0) {\r\n          this.grid.delete(key)\r\n        }\r\n      }\r\n      this.objects.delete(id)\r\n    }\r\n  }\r\n\r\n  getNearby(position: THREE.Vector3, radius: number): string[]\r\n  getNearby(x: number, y: number, z: number, radius: number): string[]\r\n  getNearby(positionOrX: THREE.Vector3 | number, radiusOrY: number, z?: number, radius?: number): string[] {\r\n    let x: number, y: number, zPos: number, searchRadius: number\r\n    \r\n    if (typeof positionOrX === 'number') {\r\n      x = positionOrX\r\n      y = radiusOrY\r\n      zPos = z!\r\n      searchRadius = radius!\r\n    } else {\r\n      x = positionOrX.x\r\n      y = positionOrX.y\r\n      zPos = positionOrX.z\r\n      searchRadius = radiusOrY\r\n    }\r\n    \r\n    const nearby: string[] = []\r\n    const cellRadius = Math.ceil(searchRadius / this.cellSize)\r\n    \r\n    const centerGridX = Math.floor(x / this.cellSize)\r\n    const centerGridY = Math.floor(y / this.cellSize)\r\n    const centerGridZ = Math.floor(zPos / this.cellSize)\r\n    \r\n    for (let dx = -cellRadius; dx <= cellRadius; dx++) {\r\n      for (let dy = -cellRadius; dy <= cellRadius; dy++) {\r\n        for (let dz = -cellRadius; dz <= cellRadius; dz++) {\r\n          const gridX = centerGridX + dx\r\n          const gridY = centerGridY + dy\r\n          const gridZ = centerGridZ + dz\r\n          const key = `${gridX},${gridY},${gridZ}`\r\n          \r\n          const cell = this.grid.get(key)\r\n          if (cell) {\r\n            nearby.push(...Array.from(cell))\r\n          }\r\n        }\r\n      }\r\n    }\r\n    \r\n    return nearby\r\n  }\r\n\r\n  getNearbyWithDistance(\r\n    position: THREE.Vector3, \r\n    radius: number\r\n  ): Array<{ id: string; distance: number; position: THREE.Vector3 }> {\r\n    const nearby = this.getNearby(position, radius)\r\n    const results: Array<{ id: string; distance: number; position: THREE.Vector3 }> = []\r\n    \r\n    for (const id of nearby) {\r\n      const objPos = this.objects.get(id)\r\n      if (objPos) {\r\n        const distance = position.distanceTo(objPos)\r\n        if (distance <= radius) {\r\n          results.push({ id, distance, position: objPos.clone() })\r\n        }\r\n      }\r\n    }\r\n    \r\n    return results.sort((a, b) => a.distance - b.distance)\r\n  }\r\n\r\n  update(id: string, newPosition: THREE.Vector3): void {\r\n    this.insert(id, newPosition)\r\n  }\r\n\r\n  clear(): void {\r\n    this.grid.clear()\r\n    this.objects.clear()\r\n  }\r\n\r\n  getStats(): { \r\n    totalObjects: number\r\n    totalCells: number\r\n    averageObjectsPerCell: number\r\n    maxObjectsInCell: number\r\n  } {\r\n    const totalObjects = this.objects.size\r\n    const totalCells = this.grid.size\r\n    \r\n    let maxObjectsInCell = 0\r\n    for (const cell of this.grid.values()) {\r\n      maxObjectsInCell = Math.max(maxObjectsInCell, cell.size)\r\n    }\r\n    \r\n    const averageObjectsPerCell = totalCells > 0 ? totalObjects / totalCells : 0\r\n    \r\n    return {\r\n      totalObjects,\r\n      totalCells,\r\n      averageObjectsPerCell,\r\n      maxObjectsInCell\r\n    }\r\n  }\r\n\r\n  getAllObjects(): Array<{ id: string; position: THREE.Vector3 }> {\r\n    const results: Array<{ id: string; position: THREE.Vector3 }> = []\r\n    for (const [id, position] of this.objects.entries()) {\r\n      results.push({ id, position: position.clone() })\r\n    }\r\n    return results\r\n  }\r\n}\r\n","/**\r\n * Performance monitoring utility for tracking app performance metrics\r\n * Provides FPS tracking, memory usage, and performance insights\r\n */\r\nexport class PerformanceMonitor {\r\n  private frameCount = 0\r\n  private lastTime = performance.now()\r\n  private fps = 60\r\n  private fpsHistory: number[] = []\r\n  private maxHistoryLength = 60 // Track last 60 FPS samples\r\n\r\n  // Memory tracking (when available)\r\n  private memoryInfo = {\r\n    usedJSHeapSize: 0,\r\n    totalJSHeapSize: 0,\r\n    jsHeapSizeLimit: 0\r\n  }\r\n\r\n  // Performance thresholds\r\n  private readonly LOW_FPS_THRESHOLD = 45\r\n  private readonly HIGH_FPS_THRESHOLD = 55\r\n  private readonly MEMORY_WARNING_THRESHOLD = 0.8 // 80% of heap limit\r\n\r\n  update(): void {\r\n    this.frameCount++\r\n    const currentTime = performance.now()\r\n    const deltaTime = currentTime - this.lastTime\r\n\r\n    if (deltaTime >= 1000) { // Update every second\r\n      this.fps = (this.frameCount * 1000) / deltaTime\r\n      this.fpsHistory.push(this.fps)\r\n      \r\n      if (this.fpsHistory.length > this.maxHistoryLength) {\r\n        this.fpsHistory.shift()\r\n      }\r\n\r\n      this.frameCount = 0\r\n      this.lastTime = currentTime\r\n\r\n      // Update memory info if available\r\n      this.updateMemoryInfo()\r\n    }\r\n  }\r\n\r\n  private updateMemoryInfo(): void {\r\n    if ('memory' in performance) {\r\n      const memory = (performance as any).memory\r\n      this.memoryInfo = {\r\n        usedJSHeapSize: memory.usedJSHeapSize,\r\n        totalJSHeapSize: memory.totalJSHeapSize,\r\n        jsHeapSizeLimit: memory.jsHeapSizeLimit\r\n      }\r\n    }\r\n  }\r\n\r\n  getFPS(): number {\r\n    return Math.round(this.fps)\r\n  }\r\n\r\n  getAverageFPS(): number {\r\n    if (this.fpsHistory.length === 0) return this.fps\r\n    const sum = this.fpsHistory.reduce((a, b) => a + b, 0)\r\n    return Math.round(sum / this.fpsHistory.length)\r\n  }\r\n\r\n  getMinFPS(): number {\r\n    if (this.fpsHistory.length === 0) return this.fps\r\n    return Math.round(Math.min(...this.fpsHistory))\r\n  }\r\n\r\n  getMaxFPS(): number {\r\n    if (this.fpsHistory.length === 0) return this.fps\r\n    return Math.round(Math.max(...this.fpsHistory))\r\n  }\r\n\r\n  getPerformanceLevel(): 'low' | 'medium' | 'high' {\r\n    const avgFPS = this.getAverageFPS()\r\n    if (avgFPS < this.LOW_FPS_THRESHOLD) return 'low'\r\n    if (avgFPS > this.HIGH_FPS_THRESHOLD) return 'high'\r\n    return 'medium'\r\n  }\r\n\r\n  getMemoryUsage(): {\r\n    used: number // MB\r\n    total: number // MB\r\n    limit: number // MB\r\n    percentage: number // 0-1\r\n    isWarning: boolean\r\n  } {\r\n    const bytesToMB = (bytes: number) => Math.round(bytes / 1024 / 1024)\r\n    \r\n    const used = bytesToMB(this.memoryInfo.usedJSHeapSize)\r\n    const total = bytesToMB(this.memoryInfo.totalJSHeapSize)\r\n    const limit = bytesToMB(this.memoryInfo.jsHeapSizeLimit)\r\n    \r\n    const percentage = limit > 0 ? used / limit : 0\r\n    const isWarning = percentage > this.MEMORY_WARNING_THRESHOLD\r\n\r\n    return { used, total, limit, percentage, isWarning }\r\n  }\r\n\r\n  getStabilityScore(): number {\r\n    if (this.fpsHistory.length < 10) return 1 // Not enough data\r\n\r\n    const avg = this.getAverageFPS()\r\n    const variance = this.fpsHistory.reduce((sum, fps) => {\r\n      return sum + Math.pow(fps - avg, 2)\r\n    }, 0) / this.fpsHistory.length\r\n\r\n    const standardDeviation = Math.sqrt(variance)\r\n    \r\n    // Stability score: lower deviation = higher stability\r\n    // Score from 0 (very unstable) to 1 (very stable)\r\n    const maxAcceptableDeviation = 10\r\n    return Math.max(0, 1 - (standardDeviation / maxAcceptableDeviation))\r\n  }\r\n\r\n  getRecommendations(): string[] {\r\n    const recommendations: string[] = []\r\n    const perfLevel = this.getPerformanceLevel()\r\n    const memory = this.getMemoryUsage()\r\n    const stability = this.getStabilityScore()\r\n\r\n    if (perfLevel === 'low') {\r\n      recommendations.push('Consider reducing particle count or 3D quality settings')\r\n      recommendations.push('Check for memory leaks or excessive object creation')\r\n    }\r\n\r\n    if (memory.isWarning) {\r\n      recommendations.push('Memory usage is high - consider enabling object pooling')\r\n      recommendations.push('Clear unused cached geometries or textures')\r\n    }\r\n\r\n    if (stability < 0.7) {\r\n      recommendations.push('Frame rate is unstable - check for blocking operations')\r\n      recommendations.push('Consider using animation scheduler frame budgeting')\r\n    }\r\n\r\n    if (recommendations.length === 0) {\r\n      recommendations.push('Performance is optimal!')\r\n    }\r\n\r\n    return recommendations\r\n  }\r\n  getFullReport(): {\r\n    fps: { current: number; average: number; min: number; max: number }\r\n    memory: { used: number; total: number; limit: number }\r\n    performance: {\r\n      level: 'low' | 'medium' | 'high'\r\n      stability: number\r\n    }\r\n    recommendations: string[]\r\n  } {\r\n    return {\r\n      fps: {\r\n        current: this.getFPS(),\r\n        average: this.getAverageFPS(),\r\n        min: this.getMinFPS(),\r\n        max: this.getMaxFPS()\r\n      },\r\n      memory: this.getMemoryUsage(),\r\n      performance: {\r\n        level: this.getPerformanceLevel(),\r\n        stability: this.getStabilityScore()\r\n      },\r\n      recommendations: this.getRecommendations()\r\n    }\r\n  }\r\n\r\n  reset(): void {\r\n    this.frameCount = 0\r\n    this.lastTime = performance.now()\r\n    this.fps = 60\r\n    this.fpsHistory = []\r\n  }\r\n}\r\n\r\n// Global performance monitor instance\r\nexport const globalPerformanceMonitor = new PerformanceMonitor()\r\n"],"names":["LRUCache","maxSize","__publicField","key","value","firstKey","AnimationScheduler","task","newTask","id","t","deltaTime","now","budget","startTime","error","newPriority","newInterval","frameUsage","budgetUsed","a","b","globalAnimationScheduler","FrustumCuller","THREE.Frustum","THREE.Matrix4","object","customBounds","bounds","THREE.Box3","camera","visible","hidden","worldBounds","item","newBounds","totalObjects","visibleCount","hiddenCount","cullingEfficiency","SpatialHashGrid","cellSize","x","y","z","gridX","gridY","gridZ","positionOrX","yPos","zPos","THREE.Vector3","obj","cell","radiusOrY","radius","searchRadius","nearby","cellRadius","centerGridX","centerGridY","centerGridZ","dx","dy","dz","position","results","objPos","distance","newPosition","totalCells","maxObjectsInCell","averageObjectsPerCell","PerformanceMonitor","currentTime","memory","sum","avgFPS","bytesToMB","bytes","used","total","limit","percentage","isWarning","avg","variance","fps","standardDeviation","recommendations","perfLevel","stability","globalPerformanceMonitor"],"mappings":"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"}